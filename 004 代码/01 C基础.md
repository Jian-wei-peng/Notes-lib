## 一、C语言介绍

### 1.1 简介

- 1972年，贝尔实验室的Dennis Ritchie（丹尼斯·里奇）在Ken Thompson（肯·汤普森）的B语言基础上发明
- 1973年初，C语言的主体完成。Thompson和Ritchie用C语言重写了UNIX
- 1977年，Dennis Ritchie发表了不依赖于具体机器系统的C语言编译程序（编译器）
- 1989年，ANSI（美国国家标准协会）发布了第一个完整的C语言标准：ANSI X3.159-1989，简称“C89”

### 1.2  为什么C语言最牛逼？

- **可直接操作底层硬件**：设备驱动程序、操作系统等
	- C语言一枝独秀，C++也有一席之地，其他高级语言无能为力
	- 电脑及智能设备的操作系统、工业控制系统、智能家居系统、嵌入式开发等等

- C语言是**速度**之王：所产生的代码与汇编语言编写的代码运行速度几乎一样

<img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202205231110095.png" alt="image-20220523111013032" style="zoom:50%;" />

- 编程语言之母。很多其它语言从C的基础上发展；几乎所有语言的编译器或解释器都是用C写的
- 全能王。从系统软件到应用软件，无所不能

### 1.3 程序和编程语言

- 程序 = 一系列对**数据**加工的**指令**

	<img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202205231115061.png" alt="image-20220523111528010" style="zoom:50%;" />

- 编程语言：**表示指令和数据的规则**

	- **机器语言**：用0和1表示指令和数据，因为计算机只能识别0和1

		- 可读性差

	- **汇编语言**：机器语言的字符化表示，每个汇编指令对应一个机器语言指令

		- 可读性差

	- **高级语言**：用类人类语言表示指令和数据

		- **编译器（解释器）**：将高级语言编程的程序转化为机器指令程序

			<img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202205231119579.png" style="zoom:50%;" />

## 二、变量与基本类型

``` c
# include <stdio.h>  // 标准库头文件

// main函数是主函数，程序入口；{ 函数体 }
main(){
    
    /* 
    声明语句：说明变量的名字及类型，也可以指定变量的初值
    所有变量都必须 “先声明，后使用”；一个声明指定一种变量类型；可在声明的同时对变量进行初始化
    */
    char a;		// 定义一个字符型变量a，占1个字节
    char a1 = 'A';
    
    int b, i = 1, j = 10;	// 整型，占2个字节
    
    float c;	// 单精度浮点型，占4个字节
    double d;	// 双精度浮点型，占8个字节
    /*
    变量：代表系统分配的内存空间，具有变量名和变量类型两个属性
    变量名：对应内存中不同的地址
    变量类型：决定一个变量占用多少个字节
    1个字节（byte）表8位二进制位，1个字节对应1个地址
    */
    
    /*
    运算符：指定将要进行的操作
    	算术运算符：
    		+、-、*、/、%
    		%取模运算符，不可用于浮点型
    	关系运算符：
    		>、>=、<、<=
    		==、！=
    	自增/自减运算符：++；--
    	赋值运算符：+=、-=、*=、/=、%=、<<=、>>=、&=、^=、|=
    表达式：将变量和常量组合起来生成新的值
    */
    
    printf("Hello World!");

}

```

**条件表达式**：

```c
expr1 ? expr2 : expr3
```

如果expr1为真，则计算expr2的值，并将该值作为输出

如果expr1为假，则计算expr3的值，并将该值作为输出

## 三、控制流

### 3.1 if-else语句

``` c
/*
语句：表达式 + ;
分号“ ; ”是语句的结束符
复合语句：用一对花括号“{”和“}”将一组声明和语句括在一起
*/

if(表达式1){
    语句1;	// 表达式1的值为真，则执行语句1
} else {
    语句2;	// 表达式1的值为假，则执行语句2
}

// if语句可嵌套
if(表达式1){
    if(表达式2){
        语句1
    } else {
    	语句2
	}	
} else {
    语句3;	
}

// else-if语句
if(表达式1){
    语句1;	
} else if(表达式2){
    语句2;	
} else if(表达式3){
    语句3;	
} else if(表达式4){
    语句3;	
} else {
    语句4；
}

```

### 3.2 switch语句

```c
/*
若某个分支与表达式的值匹配，则从该分支开始执行
若所有分支与表达式的值不匹配，则从default分支开始执行
*/

switch(表达式){
        case 常量表达式：语句序列
        case 常量表达式：语句序列
        default ：语句序列
}

/*
分支中的代码执行完后，程序将进入下一个分支继续执行，因此常用break语句结束分支程序的执行
*/
```

### 3.3 while循环

```c
// 表达式为真，则执行语句，然后再判断表达式的真假。一直循环，直至表达式为假
while(表达式){
    语句
}

/* 
do-while：循环体执行一次后再测试终止条件
与while的区别是：至少执行了一次循环体语句
*/
do{
    语句
}
while(表达式)
```

### 3.4 for循环

```c
for (表达式1；表达式2；表达式3){
    
}
```

### 3.5 break语句和continue语句

- 常用于循环结构中
- break：结束循环
- continue：结束当前循环，开始下一次循环

## 四、数组

### 4.1 一维数组

- **存放在一块连续的内存空间中，数组中的每个元素都是相同数据类型**

- **数组索引（下标）从0开始，可以通过数组下标访问数组中的元素**

1. 定义方式：
	1. **数据类型	数组名[ 数组长度 ]**;
	2. **数据类型    数组名[ 数组长度 ] = { 值1, 值2, ….}**;
	3. **数据类型    数组名[  ] = { 值1, 值2, ….}**;

示例：

```c
int main(){
    /*** 1、数据类型	数组名[ 数组长度 ] ***/
    int score[3];
    score[0] = 1;	// 元素赋值
    score[1] = 3;
    score[2] = 7;
    
    print(score[1]);	// 访问数组元素
    
    /*** 2、数据类型    数组名[ 数组长度 ] = { 值1, 值2, ….} ***/
    // 如果初始化数组时，没有给所有元素赋值初始化，则会用0来填补剩余元素
    int arr[5] = {1, 3, 7};
    
    for(int i = 0; i < 5; i++){
        print(score[i]);	// 访问数组元素
    }
    
    /*** 3、数据类型    数组名[  ] = { 值1, 值2, ….} ***/
    // 定义数组的时候，必须有初始长度
    int arr1[] = {1, 3, 7, 10, 11, 50};
    
}
```

2. 一维数组名的用途

	1. **可以统计整个数组在内存中的长度**

		<img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202205271012407.png" alt="image-20220527101207339" style="zoom:50%;" />

	2. **可以获取数组在内存中的首地址**

示例：

```c
int main(){
    // 1、统计整个数组在内存中的长度
    int arr[3] = { 1, 2, 3 };
    
    cout << sizeof(arr) << endl;	// 整个数组占用内存空间
    cout << sizeof(arr[0]) << endl;	// 每个元素占用内存空间
    cout << sizeof(arr) / sizeof(arr[0]) << endl;	// 数组中元素个数
    
    // 2、获取数组在内存中的首地址
    // 数组名就是其内存中的首地址
    cout << arr << endl
}

```

### 4.2 二维数组

**二维数组就是在一维数组上，多加一个维度（矩阵）**

<img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202205271022212.png" alt="image-20220527102206170" style="zoom:67%;" />

1. 定义方式：
	1. **数据类型	数组名[ 行数 ] [ 列数 ]**;
	2. **数据类型    数组名[ 行数 ] [ 列数 ] = { {值1, 值2} ,  {值3, 值4} ….}**;
	3. **数据类型    数组名[ 行数 ] [ 列数 ] = { 值1, 值2, 值3, 值4 ….}**;     // 没n个数为一行，n为列数
	4. **数据类型    数组名[  ] [ 列数 ] = { 值1, 值2, 值3, 值4 ….}**;

**以上4种方式，利用第二种更加直观，提高代码的可读性**

示例：

```c
int main(){
    
    int arr[2][3] = {
        {1, 2, 3},
        {4, 5, 6}
    };
    
    // 外层循环遍历行数，内层循环遍历列数
    for(int i = 0; i < 2; i++){
        for(int j = 0; j < 3; j++){
            cout << arr[i][j] << " ";
        }
        cout << endl;
    }
}

```

2. 二维数组名的用途
	1. **查看二维数组所占内存空间**
	2. **获取二维数组首地址**

示例：

```c
int main(){
    // 1、统计整个数组在内存中的长度
    int arr[2][3] = {
        {1, 2, 3},
        {4, 5, 6}
    };
    
    cout << sizeof(arr) << endl;		// 整个数组占用内存空间
    cout << sizeof(arr[0]) << endl;		// 第一行占用内存空间
    cout << sizeof(arr[0][0]) << endl;	// 第一个元素占用内存空间
    
    cout << sizeof(arr) / sizeof(arr[0]) << endl;		// 二维数组行数
    cout << sizeof(arr[0]) / sizeof(arr[0][0]) << endl;	// 二维数组列数
    
    // 2、获取数组在内存中的首地址
    // 数组名就是其内存中的首地址
    cout << arr << endl
}

```



## 五、函数

### 5.1 函数的定义与使用

**作用**：将一段经常使用的代码封装起来，减少重复代码

一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能

**函数定义的五个步骤**：

- 返回值类型
- 函数名
- 参数列表
- 函数体语句
- return表达式

```c
/* 函数的定义：
返回值类型 函数名（参数声明表）{
	
	声明和语句

}
*/

#include <stdio.h>
#define CONSTANT 1000

// 函数声明
// 函数声明可以多次，但函数的定义只可一次
int function1(char a, int b);
float function2(int c, float d);

// 主程序
main(){
    int j, q;
    char i;
    float p;
    function1(i, j);
    
    function2(q, p);   
    
}

// 定义函数
int function1(char a, int b){
    
    return 表达式;
}

float function2(int c, float d){ 
    
    return 表达式;
}

/*******4种常见函数样式*********/
// 1、无参无返
void fun01(){
    ...
}

// 2、有参无返
void fun2(int a){
    ...
}

// 3、无参有返
int fun3(){
    ...
    return 1000;
}

// 4、有参有返
int fun4(int a){
    ...
    return 20;
}
```

### 5.2 函数的分文件编写

**作用**：让代码结构更加清晰

步骤：

- **创建后缀名为 .h 的头文件**
	- **在头文件中写函数的声明**
- **创建后缀名为 .cpp 的源文件**
	- **在源文件中写函数的定义**
	- **引用上一步的.h头文件**
- **在主函数中调用函数，引用该函数的头文件**

示例：

**swap.h头文件**

```c
# include <stdio.h>

//实现两个数字交换的函数声明
void swap(int a, int b);
```

**swap.c源文件**

```c
// 双引号""代表自定义的头文件
# include "swap.h"

void swap(int a, int b){
    int temp = a;
    a = b;
    b = temp;
}

```

**main.c主程序文件**

```c
# include <stdio.h>

# include "swap.h"

int main(){
    int a = 10;
    int b = 20;
    swap(a, b);
    
    return 0;
}
```

## 六、指针

### 6.1 指针的基本概念

**指针：一种保存*变量地址* 的变量**

**指针的作用**：可以通过指针**间接访问内存**

- 内存编号是从0开始，一般用十六进制数字表示
- 可以利用指针变量保持地址

### 6.2 指针的定义和使用

**定义语法：数据类型	* 变量名**

一元运算符 * 是间接寻址或间接引用运算符

一元运算符 & 可用于取一个对象的地址

**使用语法：* 指针变量名**

示例：

```c
int main(){
    /****** 1、定义指针 ******/
    int a = 10;
    // 指针定义语法：数据类型 * 指针变量名；
    int * p;
    // 让指针记录变量a的地址
    p = &a;
    
    /****** 2、使用指针 ******/
    // 可通过 解引用 的方式来找到指针指向的内存
    // 指针前加 * 代表解引用，找到指针指向的内存中的数据
    *p = 1000;
}
```

*32位操作系统下，指针是占4个字节空间，不管是什么数据类型*

*64位操作系统下，指针是占8个字节空间*

### 6.3 空指针和野指针

**空指针**：指针变量指向内存中编号为0的空间

**用途**：初始化指针变量

**注意**：空指针指向的内存是不可以访问的（0~255之间的内存编号是系统占用的，因此不可访问）

```c
int main(){
    
    // 指针变量p指向内存地址编号为0的空间
    int * p = NULL;
    
}
```

**野指针**：指针变量指向非法的内存空间（要在程序中避免出现）

### 6.4 const修饰指针

- **常量指针：const修饰指针**（const int * p = &a）
	- 指针的指向可以修改，但是指针指向的值不可以改
- **指针常量：const修饰常量**（int * const p = &a）
	- 指针的指向不可以修改，但是指针指向的值可以改
- **const即修饰指针，又修饰常量**（const int * const p = &a）
	- 指针的指向和指针指向的值都不可以改

### 6.5 指针和数组

**利用指针访问数组中的元素**

```c
int main(){
    
    int arr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; // 数组索引从0开始
    
    /***** 利用指针访问数组元素 *****/
    // 数组名就是数组的首地址
    int * p = arr; 
    
    // 用指针访问第二个元素
    p++; // 让指针向后偏移4个字节
    
    /***** 指针遍历数组 *****/
    int * p2 = arr;
    for(int i = 0; i < 10; i++){
        cout << *p2 << endl;
        p2++;

    }   
}
```

### 6.6 指针和函数

**作用：利用指针作函数参数，可以修改实参的值**

**C/C++是以 *传值*  的方式将参数传递给被调用函数的，因此被调用函数不能直接修改主调函数中变量的值**

**值传递：函数调用的时候实参将数值传给形参**

swap01函数实现两个数字交换，在主函数main中对其调用，不改变main函数中变量的值

```c
// 实现两个数字进行交换
void swap01(int a, int b){
    int temp = a;
    a = b;
    b = temp;
}

int main(){
    //1、值传递     
    int a = 10;
    int b = 20;
    swap01(a, b);
}
```

<img src="https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202205261152881.png" alt="image-20220526115219839" style="zoom:50%;" />

**地址传递**：可以修饰实参

传入的是存储地址，在swap02函数中实现的是交换两个地址中存储的内容

```c
void swap02(int *p1, int *p2){
    int temp = *p1;
    *p1 = *p2;
    *p2 = temp;
}

int main(){
    int a = 10;
    int b = 20;
    
    swap02(&a, &b);
}
```

![image-20220526120102610](https://raw.githubusercontent.com/Jian-wei-peng/typora-pic/main/202205261201640.png)

## 七、结构体

### 7.1 结构体定义和使用

属于**用户自定义的数据类型**，允许用户存储**不同的数据类型**

**定义语法：struct 结构体名 { 结构体成员列表 }；**

**通过结构体创建变量的三种方式（常用第1和第2种方式）：**

- struct 结构体名 变量名
- struct 结构体名 变量名 = {成员1值，成员2值  … }
- 定义结构体时顺便创建变量

*在C++中，创建结构体变量时可以省略struct关键字，定义的时候不可以省略*

**结构成员运算符 . 将结构名与成员名连接，从而实现对成员的访问**

示例：

```c
/********** 结构体定义 **********/
struct Student{
    // 成员列表
    string name;
    int age;
    int score;
    
};

// 3、定义结构体时顺便创建变量
// 定义结构体的时候在末尾添加新创建的变量s3
struct Student{
    // 成员列表
    ...
}s3;

int main(){
    /******** 结构体变量 ********/
    // 1、struct 结构体名 变量名
    struct Student s1;
    s1.name = "张三";
    s1.age = 20;
    s1.score = 100;
    
    // 2、struct 结构体名 变量名 = {成员1值，成员2值  … }
    struct Student s2 = {"李四", 19, 80};    
    
    // 3、定义结构体时顺便创建变量
    s3.name = "王五";
    s3.age = 18;
    s3.score = 89;
}
```

### 7.2 结构体数组

**作用**：将自定义的结构体放入到数组中方便维护

**语法：struct 结构体名 数组名[元素个数] = { {}, {}, … , {}}**

示例：

```c
// 1、定义结构体
struct Student{
    string name;
    int age;
    int score;
};

int main(){
    // 2、 创建结构体数组
    struct Student arr[3] = {
        {"张三", 18, 80},
        {"李四", 20, 90},
        {"王五", 25, 98}
    };
    
    // 3、给结构体数组中的元素赋值
    // 可以在创建结构体数组时给各元素赋值，也可以创建完以后再赋值
    arr[2].name = "赵六";
    
    // 4、遍历结构体数组
    for (int i = 0; i < 3; i++){
        ...
        arr[i];
        ...
    } 
}
```

### 7.3 结构体指针

**作用**：通过指针访问结构体中的成员

- 利用操作符 **->** 可以通过结构体指针访问结构体属性

示例：

```c
struct Student{
    string name;
    int age;
    int score;
};

int main(){
    
    // 1、创建结构体变量
    struct Student stu = {"张三", 18, 100};
    
    // 2、通过指针指向结构体变量（结构体指针变量）
    struct Student * p = &stu;
    
    // 3、通过指针访问结构体变量中的数据
    print( p -> name );
    print( (*p).name );
    
}
```

### 7.4 结构体嵌套

**作用**：结构体中的成员可以是另一个结构体

例如：每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体

示例：

```c
// 学生结构体
struct Student{
    string name;
    int age;
    int score;
};

// 老师结构体
struct Teacher{
    int id;
    string name;
    int age;
    struct Student stu;		// 子结构体	学生
};

int main(){
    // 结构体嵌套
    // 创建老师
    struct Teacher t;
    t.id = 10000;
    t.name = "汪";
    t.age = 40;
    t.stu.name = "王";
    t.stu.age = 20;
    t.stu.score = 100; 
}
```

### 7.5 结构体作函数参数

**作用**：将结构体作为参数向函数中传递

传递方式：

- **值传递**
- **地址传递**

示例：

```c
struct Student{
    string name;
    int age;
    int score;
};

// 值传递
void printStudent1(struct Student stu){
    stu.age = 28;		// 值传递不改变主函数中的变量
    printf(stu.name);
    printf(stu.age);
}

// 地址传递
void printStudent2(struct Student * p){
    p -> age = 28;		// 地址传递会改变主函数中的变量
    printf( p -> age);
    printf( p -> name);
    printf( p -> score);
}

int main(){
    // 创建结构体变量
    struct Student s;
    s.name = "张三";
    s.age = 10;
    s.score = 80;
    
    // 值传递
    printStudent1(s);
    
    // 地址传递
    printStudent2(&s);
}

```

### 7.6 结构体中const使用场景

**作用**：用const来防止误操作

示例：

```c
struct Student{
    string name;
    int age;
    int score;
};

// const防止误操作
void printStudent(const struct Student *stu){
    // stu -> age = 20;	// 错误
    print(...);
}

int main(){
    struct Student s = {"张三", 18, 90};
    
    // 通过函数打印结构体信息
    // 值传递需要另外开辟内存空间对变量进行副本赋值，用地址传递不需要，能够节省内存空间
    printStudent(&s);
}
```







































